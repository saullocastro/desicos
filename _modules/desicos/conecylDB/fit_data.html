
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>desicos.conecylDB.fit_data &#8212; DESICOS 2.4.12 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for desicos.conecylDB.fit_data</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fitting Data (:mod:`desicos.conecylDB.fit_data`)</span>
<span class="sd">==================================================</span>

<span class="sd">.. currentmodule:: desicos.conecylDB.fit_data</span>

<span class="sd">This module includes functions used to fit measured imperfection data.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">sample</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">deg2rad</span>

<span class="kn">from</span> <span class="nn">desicos.logger</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">desicos.constants</span> <span class="kn">import</span> <span class="n">FLOAT</span>


<div class="viewcode-block" id="best_fit_cylinder"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.best_fit_cylinder">[docs]</a><span class="k">def</span> <span class="nf">best_fit_cylinder</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">R_expected</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">errorRtol</span><span class="o">=</span><span class="mf">1.e-9</span><span class="p">,</span>
                      <span class="n">maxNumIter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fit a best cylinder for a given set of measured data</span>

<span class="sd">    The coordinate transformation which must be performed in order to adjust</span>
<span class="sd">    the raw data to the finite element coordinate system is illustrated below:</span>

<span class="sd">    .. figure:: ../../../figures/modules/conecylDB/fit_data/coord_sys_trans.png</span>
<span class="sd">        :width: 400</span>

<span class="sd">    This transformation can be represented in matrix form as:</span>

<span class="sd">    .. math::</span>
<span class="sd">     [T] = \begin{bmatrix}</span>
<span class="sd">     cos(\beta) &amp;  sin(\alpha)sin(\beta) &amp; -cos(\alpha)sin(\beta) &amp; \Delta x_0</span>
<span class="sd">     \\</span>
<span class="sd">              0 &amp;            cos(\alpha) &amp;            sin(\alpha) &amp; \Delta y_0</span>
<span class="sd">     \\</span>
<span class="sd">     sin(\beta) &amp; -sin(\alpha)cos(\beta) &amp;  cos(\alpha)cos(\beta) &amp; \Delta z_0</span>
<span class="sd">     \\</span>
<span class="sd">           \end{bmatrix}</span>

<span class="sd">    Note that **five** variables are unknowns:</span>

<span class="sd">    - the rotation angles `\alpha` and `\beta`</span>
<span class="sd">    - the three components of the translation `\Delta x_0`, `\Delta y_0` and</span>
<span class="sd">      `\Delta z_0`</span>

<span class="sd">    The five unknowns are calculated iteratively in a non-linear least-sqares</span>
<span class="sd">    problem (solved with ``scipy.optimize.leastsq``), where the measured data</span>
<span class="sd">    is transformed to the reference coordinate system and there compared with</span>
<span class="sd">    a reference cylinder in order to compute the residual error using:</span>

<span class="sd">    .. math::</span>
<span class="sd">        \begin{Bmatrix} x_{ref} \\ y_{ref} \\ z_{ref} \end{Bmatrix} =</span>
<span class="sd">        [T]</span>
<span class="sd">        \begin{Bmatrix} x_m \\ y_m \\ z_m \\ 1 \end{Bmatrix}</span>
<span class="sd">        \\</span>
<span class="sd">        Error = \sqrt{(\Delta r)^2 + (\Delta z)^2}</span>

<span class="sd">    where:</span>

<span class="sd">    - `x_m`, `y_m` and `z_m` are the data coordinates in the data coordinate</span>
<span class="sd">      system</span>
<span class="sd">    - `x_{ref}` `x_{ref}` are the data coordinates in the :ref:`reference</span>
<span class="sd">      coordinate system &lt;figure_conecyl&gt;`</span>
<span class="sd">    - `\Delta r` and `\Delta z` are defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \Delta r = R - \sqrt{x_{ref}^2 + y_{ref}^2}</span>
<span class="sd">            \\</span>
<span class="sd">            \Delta z = \begin{cases}</span>
<span class="sd">                            -z_{ref}, &amp; \text{if } z_{ref} &lt; 0 \\</span>
<span class="sd">                                   0, &amp; \text{if } 0 &lt;= z_{ref} &lt;= H \\</span>
<span class="sd">                         z_{ref} - H, &amp; \text{if } z_{ref} &gt; H \\</span>
<span class="sd">                       \end{cases}</span>

<span class="sd">    Since the measured data may have an unknown radius `R`, the solution of</span>
<span class="sd">    these equations has to be performed iteratively with one additional</span>
<span class="sd">    external loop in order to update `R`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str or np.ndarray</span>
<span class="sd">        The path of the file containing the data. Can be a full path using</span>
<span class="sd">        ``r&quot;C:\Temp\inputfile.txt&quot;``, for example.</span>
<span class="sd">        The input file must have 3 columns &quot;`x` `y` `z`&quot; expressed</span>
<span class="sd">        in Cartesian coordinates.</span>

<span class="sd">        This input can also be a ``np.ndarray`` object, with `x`, `y`, `z`</span>
<span class="sd">        in each corresponding column.</span>
<span class="sd">    H : float</span>
<span class="sd">        The nominal height of the cylinder.</span>
<span class="sd">    R_expected : float, optional</span>
<span class="sd">        The nominal radius of the cylinder, used as a first guess to find</span>
<span class="sd">        the best-fit radius (``R_best_fit``). Note that if not specified more</span>
<span class="sd">        iterations may be required.</span>
<span class="sd">    save : bool, optional</span>
<span class="sd">        Whether to save an ``&quot;output_best_fit.txt&quot;`` in the working directory.</span>
<span class="sd">    errorRtol : float, optional</span>
<span class="sd">        The error tolerance for the best-fit radius to stop the iterations.</span>
<span class="sd">    maxNumIter : int, optional</span>
<span class="sd">        The maximum number of iterations for the best-fit radius.</span>
<span class="sd">    sample_size : int, optional</span>
<span class="sd">        If the input file containing the measured data is too big it may</span>
<span class="sd">        be convenient to use only a sample of it in order to calculate the</span>
<span class="sd">        best fit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dict</span>
<span class="sd">        A Python dictionary with the entries:</span>

<span class="sd">        ``out[&#39;R_best_fit&#39;]`` : float</span>
<span class="sd">            The best-fit radius of the input sample.</span>
<span class="sd">        ``out[&#39;T&#39;]`` : np.ndarray</span>
<span class="sd">            The transformation matrix as a `3 \times 4` 2-D array. This matrix</span>
<span class="sd">            does the transformation: input_pts --&gt; output_pts.</span>
<span class="sd">        ``out[&#39;Tinv&#39;]`` : np.ndarray</span>
<span class="sd">            The inverse transformation matrix as a `3 \times 4` 2-D array.</span>
<span class="sd">            This matrix does the transformation: output_pts --&gt; input_pts.</span>
<span class="sd">        ``out[&#39;input_pts&#39;]`` : np.ndarray</span>
<span class="sd">            The input points in a `3 \times N` 2-D array.</span>
<span class="sd">        ``out[&#39;output_pts&#39;]`` : np.ndarray</span>
<span class="sd">            The transformed points in a `3 \times N` 2-D array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    1) General usage</span>

<span class="sd">    For a given cylinder with expected radius and height of ``R_expected`` and</span>
<span class="sd">    ``H``::</span>

<span class="sd">        from desicos.conecylDB.fit_data import best_fit_cylinder</span>

<span class="sd">        out = best_fit_cylinder(path, H=H, R_expected=R_expected)</span>
<span class="sd">        R_best_fit = out[&#39;R_best_fit&#39;]</span>
<span class="sd">        T = out[&#39;T&#39;]</span>
<span class="sd">        Tinv = out[&#39;Tinv&#39;]</span>

<span class="sd">    2) Using the transformation matrices ``T`` and ``Tinv``</span>

<span class="sd">    For a given input data with `x, y, z` positions in each line::</span>

<span class="sd">        x, y, z = np.loadtxt(&#39;input_file.txt&#39;, unpack=True)</span>

<span class="sd">    the transformation could be obtained with::</span>

<span class="sd">        xnew, ynew, znew = T.dot(np.vstack((x, y, z, np.ones_like(x))))</span>

<span class="sd">    and the inverse transformation::</span>

<span class="sd">        x, y, z = Tinv.dot(np.vstack((xnew, ynew, znew, np.ones_like(xnew))))</span>



<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">leastsq</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">input_pts</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">input_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input does not have the format: &quot;x, y, z&quot;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sample_size</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">input_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sample_size</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">input_pts</span> <span class="o">=</span> <span class="n">input_pts</span><span class="p">[:,</span> <span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))]</span>

    <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">input_pts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">input_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])))</span>

    <span class="k">def</span> <span class="nf">fT</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span> <span class="o">=</span> <span class="n">p</span>
        <span class="n">a</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">b</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># rotation in x, y</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>  <span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">x0</span><span class="p">],</span>
                      <span class="p">[</span>     <span class="mi">0</span><span class="p">,</span>         <span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>         <span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">y0</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>  <span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">z0</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">T</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">R_expected</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxNumIter</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">def</span> <span class="nf">calc_dist</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pts</span><span class="p">):</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">fT</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">,</span> <span class="n">zn</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">zn</span><span class="p">)</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="c1"># point below the bottom edge</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">zn</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="n">dz</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">zn</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="n">factor</span>

            <span class="c1"># point inside the cylinder</span>
            <span class="k">pass</span>
            <span class="c1">#dz[(zn &gt;= 0) &amp; (zn &lt;= H)] *= 0</span>

            <span class="c1"># point above the top edge</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">zn</span> <span class="o">&gt;</span> <span class="n">H</span>
            <span class="n">dz</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">zn</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-</span> <span class="n">H</span><span class="p">)</span><span class="o">*</span><span class="n">factor</span>

            <span class="n">dr</span> <span class="o">=</span> <span class="n">R</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xn</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">yn</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">dz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dist</span>

        <span class="c1"># initial guess for the optimization variables</span>
        <span class="c1"># the variables are alpha, beta, x0, y0, z0</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">input_pts</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">.</span><span class="n">mean</span><span class="p">(),</span> <span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">mean</span><span class="p">()]</span>

        <span class="c1"># performing the leastsq analysis</span>
        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">leastsq</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">calc_dist</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">pts</span><span class="p">,),</span>
                             <span class="n">ftol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1.e-12</span><span class="p">,</span> <span class="n">maxfev</span><span class="o">=</span><span class="mi">1000000</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">fT</span><span class="p">(</span><span class="n">popt</span><span class="p">)</span>
        <span class="n">output_pts</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">output_pts</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">z</span><span class="o">&lt;=</span><span class="n">H</span><span class="p">)</span>
        <span class="n">R_best_fit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">errorR</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">R_best_fit</span> <span class="o">-</span> <span class="n">R</span><span class="p">)</span><span class="o">/</span><span class="n">R_best_fit</span>

        <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Iteration: </span><span class="si">{0}</span><span class="s1">, R_best_fit: </span><span class="si">{1}</span><span class="s1">, errorR: </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">R_best_fit</span><span class="p">,</span> <span class="n">errorR</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">errorR</span> <span class="o">&lt;</span> <span class="n">errorRtol</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R_best_fit</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The maximum number of iterations was achieved!&#39;</span><span class="p">)</span>

    <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">beta</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Transformation matrix:</span><span class="se">\n</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Z versor: </span><span class="si">{0}</span><span class="s1">*i + </span><span class="si">{1}</span><span class="s1">*j + </span><span class="si">{2}</span><span class="s1">*k&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;alpha: </span><span class="si">{0}</span><span class="s1"> rad; beta: </span><span class="si">{1}</span><span class="s1"> rad&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;x0, y0, z0: </span><span class="si">{0}</span><span class="s1">, </span><span class="si">{1}</span><span class="s1">, </span><span class="si">{2}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Best fit radius: </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R_best_fit</span><span class="p">))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;    errorR: </span><span class="si">{0}</span><span class="s1">, numiter: </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">errorR</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="s1">&#39;output_best_fit.txt&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="n">Tinv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="n">Tinv</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="n">Tinv</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">T</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">R_best_fit</span><span class="o">=</span><span class="n">R_best_fit</span><span class="p">,</span>
                <span class="n">input_pts</span><span class="o">=</span><span class="n">input_pts</span><span class="p">,</span>
                <span class="n">output_pts</span><span class="o">=</span><span class="n">output_pts</span><span class="p">,</span>
                <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">Tinv</span><span class="o">=</span><span class="n">Tinv</span><span class="p">)</span></div>


<div class="viewcode-block" id="best_fit_cone"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.best_fit_cone">[docs]</a><span class="k">def</span> <span class="nf">best_fit_cone</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">alphadeg</span><span class="p">,</span> <span class="n">R_expected</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">errorRtol</span><span class="o">=</span><span class="mf">1.e-9</span><span class="p">,</span> <span class="n">maxNumIter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fit a best cone for a given set of measured data</span>

<span class="sd">    .. note:: NOT IMPLEMENTED YET</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Function not implemented yet!&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="calc_c0"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.calc_c0">[docs]</a><span class="k">def</span> <span class="nf">calc_c0</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">m0</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">n0</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">funcnum</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fem_meridian_bot2top</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">rotatedeg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_m0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_n0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">maxmem</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Find the coefficients that best fit the `w_0` imperfection</span>

<span class="sd">    The measured data will be fit using one of the following functions,</span>
<span class="sd">    selected using the ``funcnum`` parameter:</span>

<span class="sd">    1) Half-Sine Function</span>

<span class="sd">    .. math::</span>
<span class="sd">        w_0 = \sum_{i=1}^{m_0}{ \sum_{j=0}^{n_0}{</span>
<span class="sd">                 {c_0}_{ij}^a sin{b_z} sin{b_\theta}</span>
<span class="sd">                +{c_0}_{ij}^b sin{b_z} cos{b_\theta} }}</span>

<span class="sd">    2) Half-Cosine Function (default)</span>

<span class="sd">    .. math::</span>
<span class="sd">        w_0 = \sum_{i=0}^{m_0}{ \sum_{j=0}^{n_0}{</span>
<span class="sd">                {c_0}_{ij}^a cos{b_z} sin{b_\theta}</span>
<span class="sd">                +{c_0}_{ij}^b cos{b_z} cos{b_\theta} }}</span>

<span class="sd">    3) Complete Fourier Series</span>

<span class="sd">    .. math::</span>
<span class="sd">        w_0 = \sum_{i=0}^{m_0}{ \sum_{j=0}^{n_0}{</span>
<span class="sd">                 {c_0}_{ij}^a sin{b_z} sin{b_\theta}</span>
<span class="sd">                +{c_0}_{ij}^b sin{b_z} cos{b_\theta}</span>
<span class="sd">                +{c_0}_{ij}^c cos{b_z} sin{b_\theta}</span>
<span class="sd">                +{c_0}_{ij}^d cos{b_z} cos{b_\theta} }}</span>

<span class="sd">    where:</span>

<span class="sd">    .. math::</span>
<span class="sd">        b_z = i \pi \frac z H_{points}</span>

<span class="sd">        b_\theta = j \theta</span>

<span class="sd">    where `H_{points}` represents the difference between the maximum and</span>
<span class="sd">    the minimum `z` values in the imperfection file.</span>

<span class="sd">    The approximation can be written in matrix form as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        w_0 = [g] \{c_0\}</span>

<span class="sd">    where `[g]` carries the base functions and `{c_0}` the respective</span>
<span class="sd">    amplitudes. The solution consists on finding the best `{c_0}` that</span>
<span class="sd">    minimizes the least-square error between the measured imperfection pattern</span>
<span class="sd">    and the `w_0` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str or np.ndarray</span>
<span class="sd">        The path of the file containing the data. Can be a full path using</span>
<span class="sd">        ``r&quot;C:\Temp\inputfile.txt&quot;``, for example.</span>
<span class="sd">        The input file must have 3 columns &quot;`\theta` `z` `imp`&quot; expressed</span>
<span class="sd">        in Cartesian coordinates.</span>

<span class="sd">        This input can also be a ``np.ndarray`` object, with</span>
<span class="sd">        `\theta`, `z`, `imp` in each corresponding column.</span>
<span class="sd">    m0 : int</span>
<span class="sd">        Number of terms along the meridian (`z`).</span>
<span class="sd">    n0 : int</span>
<span class="sd">        Number of terms along the circumference (`\theta`).</span>
<span class="sd">    funcnum : int, optional</span>
<span class="sd">        As explained above, selects the base functions used for</span>
<span class="sd">        the approximation.</span>
<span class="sd">    fem_meridian_bot2top : bool, optional</span>
<span class="sd">        A boolean indicating if the finite element has the `x` axis starting</span>
<span class="sd">        at the bottom or at the top.</span>
<span class="sd">    rotatedeg : float or None, optional</span>
<span class="sd">        Rotation angle in degrees telling how much the imperfection pattern</span>
<span class="sd">        should be rotated about the `X_3` (or `Z`) axis.</span>
<span class="sd">    filter_m0 : list, optional</span>
<span class="sd">        The values of ``m0`` that should be filtered (see :func:`.filter_c0`).</span>
<span class="sd">    filter_n0 : list, optional</span>
<span class="sd">        The values of ``n0`` that should be filtered (see :func:`.filter_c0`).</span>
<span class="sd">    sample_size : int or None, optional</span>
<span class="sd">        An in  specifying how many points of the imperfection file should</span>
<span class="sd">        be used. If ``None`` is used all points file will be used in the</span>
<span class="sd">        computations.</span>
<span class="sd">    maxmem : int, optional</span>
<span class="sd">        Maximum RAM memory in GB allowed to compute the base functions.</span>
<span class="sd">        The ``scipy.interpolate.lstsq`` will go beyond this limit.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : np.ndarray</span>
<span class="sd">        A 1-D array with the best-fit coefficients.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If a similar imperfection pattern is expected along the meridian and along</span>
<span class="sd">    the circumference, the analyst can use an optimized relation between</span>
<span class="sd">    ``m0`` and ``n0`` in order to achieve a higher accuracy for a given</span>
<span class="sd">    computational cost, as proposed by Castro et al. (2014):</span>

<span class="sd">    .. math::</span>
<span class="sd">        n_0 = m_0 \frac{\pi(R_{bot}+R_{top})}{2H}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">lstsq</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">input_pts</span> <span class="o">=</span> <span class="n">path</span>
        <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;unmamed.txt&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">input_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input does not have the format: &quot;theta, z, imp&quot;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">input_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="ow">or</span> <span class="n">input_pts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;In the input: &quot;theta, z, imp&quot;; &quot;theta&quot; must be in radians!&#39;</span><span class="p">)</span>

    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Finding c0 coefficients for </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">path</span><span class="p">))))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;using funcnum </span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">funcnum</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sample_size</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">input_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sample_size</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">:</span>
            <span class="n">input_pts</span> <span class="o">=</span> <span class="n">input_pts</span><span class="p">[</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_size</span><span class="p">))]</span>

    <span class="k">if</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Valid values for &quot;funcnum&quot; are 1, 2 or 3&#39;</span><span class="p">)</span>

    <span class="c1"># the least-squares algorithm uses approximately the double the memory</span>
    <span class="c1"># used by the coefficients matrix. This is non-linear though.</span>
    <span class="n">memfac</span> <span class="o">=</span> <span class="mf">2.2</span>

    <span class="n">maxnum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxmem</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">8</span><span class="o">/</span><span class="p">(</span><span class="mf">64.</span><span class="o">*</span><span class="n">size</span><span class="o">*</span><span class="n">m0</span><span class="o">*</span><span class="n">n0</span><span class="p">)</span><span class="o">/</span><span class="n">memfac</span><span class="p">)</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">input_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="n">maxnum</span><span class="p">:</span>
        <span class="n">input_pts</span> <span class="o">=</span> <span class="n">input_pts</span><span class="p">[</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">maxnum</span><span class="p">))]</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Using </span><span class="si">{0}</span><span class="s1"> measured points due to the &quot;maxmem&quot; specified&#39;</span><span class="o">.</span>
                <span class="nb">format</span><span class="p">(</span><span class="n">maxnum</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">ts</span> <span class="o">=</span> <span class="n">input_pts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">rotatedeg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">+=</span> <span class="n">deg2rad</span><span class="p">(</span><span class="n">rotatedeg</span><span class="p">)</span>
    <span class="n">zs</span> <span class="o">=</span> <span class="n">input_pts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">w0pts</span> <span class="o">=</span> <span class="n">input_pts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="c1">#NOTE using `H_measured` did not allow a good fitting result</span>
    <span class="c1">#zs /= H_measured</span>
    <span class="n">zs</span> <span class="o">=</span> <span class="p">(</span><span class="n">zs</span> <span class="o">-</span> <span class="n">zs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="n">zs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">zs</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fem_meridian_bot2top</span><span class="p">:</span>
        <span class="c1">#TODO</span>
        <span class="n">zs</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">zs</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">fa</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">funcnum</span><span class="p">)</span>

    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Base functions calculated&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">c0</span><span class="p">,</span> <span class="n">residues</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">lstsq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w0pts</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Finished scipy.linalg.lstsq&#39;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filter_m0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_n0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="n">filter_c0</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">filter_m0</span><span class="p">,</span> <span class="n">filter_n0</span><span class="p">,</span> <span class="n">funcnum</span><span class="o">=</span><span class="n">funcnum</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">c0</span><span class="p">,</span> <span class="n">residues</span></div>


<div class="viewcode-block" id="filter_c0"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.filter_c0">[docs]</a><span class="k">def</span> <span class="nf">filter_c0</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">filter_m0</span><span class="p">,</span> <span class="n">filter_n0</span><span class="p">,</span> <span class="n">funcnum</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply filter to the imperfection coefficients `\{c_0\}`</span>

<span class="sd">    A filter consists on removing some frequencies that are known to be</span>
<span class="sd">    related to rigid body modes or spurious measurement noise. The frequencies</span>
<span class="sd">    to be removed should be passed through inputs ``filter_m0`` and</span>
<span class="sd">    ``filter_n0``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m0 : int</span>
<span class="sd">        The number of terms along the meridian.</span>
<span class="sd">    n0 : int</span>
<span class="sd">        The number of terms along the circumference.</span>
<span class="sd">    c0 : np.ndarray</span>
<span class="sd">        The coefficients of the imperfection pattern.</span>
<span class="sd">    filter_m0 : list</span>
<span class="sd">        The values of ``m0`` that should be filtered.</span>
<span class="sd">    filter_n0 : list</span>
<span class="sd">        The values of ``n0`` that should be filtered.</span>
<span class="sd">    funcnum : int, optional</span>
<span class="sd">        The function used for the approximation (see function :func:`.calc_c0`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c0_filtered : np.ndarray</span>
<span class="sd">        The filtered coefficients of the imperfection pattern.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Applying filter...&#39;</span><span class="p">)</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;using c0.shape=</span><span class="si">{0}</span><span class="s1">, funcnum=</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">funcnum</span><span class="p">),</span> <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">fm0</span> <span class="o">=</span> <span class="n">filter_m0</span>
    <span class="n">fn0</span> <span class="o">=</span> <span class="n">filter_n0</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;using filter_m0=</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fm0</span><span class="p">))</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;using filter_n0=</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fn0</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For funcnum==1 m0 starts at 1!&#39;</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m0</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span>
                <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m0</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)]</span> <span class="o">+</span>
                <span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="p">([</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">]</span> <span class="o">+</span>
               <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">fm0</span><span class="p">])</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="p">([</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)]</span> <span class="o">+</span>
                <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)]</span> <span class="o">+</span>
                <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)]</span> <span class="o">+</span>
                <span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">m0</span><span class="o">*</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">fn0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)])</span>
    <span class="n">c0_filtered</span> <span class="o">=</span> <span class="n">c0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">c0_filtered</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">log</span><span class="p">(</span><span class="s1">&#39;Filter applied!&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">c0_filtered</span></div>


<div class="viewcode-block" id="fa"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.fa">[docs]</a><span class="k">def</span> <span class="nf">fa</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">zs_norm</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <span class="n">funcnum</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculates the matrix with the base functions for `w_0`</span>

<span class="sd">    The calculated matrix is directly used to calculate the `w_0` displacement</span>
<span class="sd">    field, when the corresponding coefficients `c_0` are known, through::</span>

<span class="sd">        a = fa(m0, n0, zs_norm, thetas, funcnum)</span>
<span class="sd">        w0 = a.dot(c0)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m0 : int</span>
<span class="sd">        The number of terms along the meridian.</span>
<span class="sd">    n0 : int</span>
<span class="sd">        The number of terms along the circumference.</span>
<span class="sd">    zs_norm : np.ndarray</span>
<span class="sd">        The normalized `z` coordinates (from 0. to 1.) used to compute</span>
<span class="sd">        the base functions.</span>
<span class="sd">    thetas : np.ndarray</span>
<span class="sd">        The angles in radians representing the circumferential positions.</span>
<span class="sd">    funcnum : int, optional</span>
<span class="sd">        The function used for the approximation (see function :func:`.calc_c0`)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">_fit_data</span>
        <span class="k">return</span> <span class="n">_fit_data</span><span class="o">.</span><span class="n">fa</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">zs_norm</span><span class="p">,</span> <span class="n">thetas</span><span class="p">,</span> <span class="n">funcnum</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;_fit_data.pyx could not be imported, executing in Python/NumPy&#39;</span>
                <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\t\t</span><span class="s1">This mode is slower and needs more memory than the&#39;</span>
                <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n\t\t</span><span class="s1">Python/NumPy/Cython mode&#39;</span><span class="p">,</span>
             <span class="n">level</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">zs</span> <span class="o">=</span> <span class="n">zs_norm</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">thetas</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">zs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">zsmin</span> <span class="o">=</span> <span class="n">zs</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">zsmax</span> <span class="o">=</span> <span class="n">zs</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">zsmin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">zsmax</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">log</span><span class="p">(</span><span class="s1">&#39;zs.min()=</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zsmin</span><span class="p">))</span>
            <span class="n">log</span><span class="p">(</span><span class="s1">&#39;zs.max()=</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zsmax</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The zs array must be normalized!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">)]</span>
                           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m0</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">)]</span>
                           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">),</span> <span class="n">sin</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">),</span>
                           <span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">),</span> <span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">zs</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">ts</span><span class="p">)]</span>
                           <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m0</span><span class="p">)])</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="fw0"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.fw0">[docs]</a><span class="k">def</span> <span class="nf">fw0</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">xs_norm</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">funcnum</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the imperfection field `w_0` for a given input</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m0 : int</span>
<span class="sd">        The number of terms along the meridian.</span>
<span class="sd">    n0 : int</span>
<span class="sd">        The number of terms along the circumference.</span>
<span class="sd">    c0 : np.ndarray</span>
<span class="sd">        The coefficients of the imperfection pattern.</span>
<span class="sd">    xs_norm : np.ndarray</span>
<span class="sd">        The meridian coordinate (`x`) normalized to be between ``0.`` and</span>
<span class="sd">        ``1.``.</span>
<span class="sd">    ts : np.ndarray</span>
<span class="sd">        The angles in radians representing the circumferential coordinate</span>
<span class="sd">        (`\theta`).</span>
<span class="sd">    funcnum : int, optional</span>
<span class="sd">        The function used for the approximation (see function :func:`.calc_c0`)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w0s : np.ndarray</span>
<span class="sd">        An array with the same shape of ``xs_norm`` containing the calculated</span>
<span class="sd">        imperfections.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The inputs ``xs_norm`` and ``ts`` must be of the same size.</span>

<span class="sd">    The inputs must satisfy ``c0.shape[0] == size*m0*n0``, where:</span>

<span class="sd">    - ``size=2`` if ``funcnum==1 or funcnum==2``</span>
<span class="sd">    - ``size=4`` if ``funcnum==3``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">xs_norm</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;xs_norm and ts must have the same shape&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">funcnum</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="n">c0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">size</span><span class="o">*</span><span class="n">m0</span><span class="o">*</span><span class="n">n0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid c0 for the given m0 and n0!&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">_fit_data</span>
        <span class="n">w0s</span> <span class="o">=</span> <span class="n">_fit_data</span><span class="o">.</span><span class="n">fw0</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">xs_norm</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">ts</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">funcnum</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">fa</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">xs_norm</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">ts</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">funcnum</span><span class="p">)</span>
        <span class="n">w0s</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w0s</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xs_norm</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="transf_matrix"><a class="viewcode-back" href="../../../modules/conecylDB/index.html#desicos.conecylDB.fit_data.transf_matrix">[docs]</a><span class="k">def</span> <span class="nf">transf_matrix</span><span class="p">(</span><span class="n">alphadeg</span><span class="p">,</span> <span class="n">betadeg</span><span class="p">,</span> <span class="n">gammadeg</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">z0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates the transformation matrix</span>

<span class="sd">    The transformation matrix `[T]` is used to transform a set of points</span>
<span class="sd">    from one coordinate system to another.</span>

<span class="sd">    Many routines in the ``desicos`` require a transformation matrix when</span>
<span class="sd">    the coordinate system is different than :ref:`the default one</span>
<span class="sd">    &lt;figure_conecyl&gt;`. In such cases the angles `\alpha, \beta, \gamma` and</span>
<span class="sd">    the translations `\Delta x_0, \Delta y_0, \Delta z_0` represent how</span>
<span class="sd">    the user&#39;s coordinate system differs from the default.</span>

<span class="sd">    .. math::</span>
<span class="sd">         [T] = \begin{bmatrix}</span>
<span class="sd">         cos(\beta)cos(\gamma) &amp;</span>
<span class="sd">         sin(\alpha)sin(\beta)cos(\gamma) + cos(\alpha)sin(\gamma) &amp;</span>
<span class="sd">         sin(\alpha)sin(\gamma) - cos(\alpha)sin(\beta)cos(\gamma) &amp;</span>
<span class="sd">         \Delta x_0</span>
<span class="sd">         \\</span>
<span class="sd">         -cos(\beta)sin(\gamma) &amp;</span>
<span class="sd">         cos(\alpha)cos(\gamma) - sin(\alpha)sin(\beta)sin(\gamma)&amp;</span>
<span class="sd">         sin(\alpha)cos(\gamma) + cos(\alpha)sin(\beta)sin(\gamma) &amp;</span>
<span class="sd">         \Delta y_0</span>
<span class="sd">         \\</span>
<span class="sd">         sin(\beta) &amp;</span>
<span class="sd">         -sin(\alpha)cos(\beta) &amp;</span>
<span class="sd">         cos(\alpha)cos(\beta) &amp;</span>
<span class="sd">         \Delta z_0</span>
<span class="sd">         \\</span>
<span class="sd">               \end{bmatrix}</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    alphadeg : float</span>
<span class="sd">        Rotation around the x axis, in degrees.</span>
<span class="sd">    betadeg : float</span>
<span class="sd">        Rotation around the y axis, in degrees.</span>
<span class="sd">    gammadeg : float</span>
<span class="sd">        Rotation around the z axis, in degrees.</span>
<span class="sd">    x0 : float</span>
<span class="sd">        Translation along the x axis.</span>
<span class="sd">    y0 : float</span>
<span class="sd">        Translation along the y axis.</span>
<span class="sd">    z0 : float</span>
<span class="sd">        Translation along the z axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T : np.ndarray</span>
<span class="sd">        The 3 by 4 transformation matrix.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">deg2rad</span><span class="p">(</span><span class="n">alphadeg</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">deg2rad</span><span class="p">(</span><span class="n">betadeg</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">deg2rad</span><span class="p">(</span><span class="n">gammadeg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span>
                   <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span> <span class="n">x0</span><span class="p">],</span>
                  <span class="p">[</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">),</span>
                   <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span>
                   <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">+</span> <span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">g</span><span class="p">)),</span> <span class="n">y0</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>  <span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">z0</span><span class="p">]])</span></div>


<span class="k">if</span> <span class="vm">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

    <span class="kn">from</span> <span class="nn">_fit_data</span> <span class="kn">import</span> <span class="n">fa</span>

    <span class="n">path</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;C:\clones\desicos\desicos\conecylDB\files\dlr\degenhardt_2010_z25\degenhardt_2010_z25_msi_theta_z_imp.txt&#39;</span>
    <span class="n">m0</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">n0</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">c0</span><span class="p">,</span> <span class="n">residues</span> <span class="o">=</span> <span class="n">calc_c0</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">m0</span><span class="o">=</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="o">=</span><span class="n">n0</span><span class="p">,</span> <span class="n">sample_size</span><span class="o">=</span><span class="mf">0.75</span><span class="p">)</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">pi</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

    <span class="n">theta</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">fa</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">theta</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">funcnum</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

    <span class="n">levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">400</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;plot.png&#39;</span><span class="p">,</span> <span class="n">transparent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">,</span> <span class="n">pad_inches</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>



</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/desicos.png" alt="Logo"/>
    
  </a>
</p>










<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules/index.html">Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2012-2020 Desicos Improved Software Team.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>